\b;Hi
Welcome to Colobot: Gold Edition, a real-time strategy game where you save the world by programming robots! This is one of the many game modes available, namely Programming Course or just Exercises. Here you will not only gain fundamental and advanced knowledge about bot programming but also learn to think like a programmer, maybe even like a computer scientist. After this course, you should be able to program your way through the game in the other game modes and also get an unfair advantage of experience when you decide to learn the real-world programming. All you have to do is to beat this game. Isn't that amazing?

\b;Satellite Communicator
You are reading this message on your mobile Satellite Communicator, shortly \button 63;. Your task along with some useful information will be provided to you in every mission, so always read briefings sent to your \button 63;. You can always reopen it by pressing \key;\key help;\norm; on your keyboard. Information about the \button 63; navigation can be found \l;here\u navig;, although you probably don't need to read it if you've ever used a web browser.

\b;Programming

\t;Why Program?
Imagine yourself building a base. In the beginning it's easy, you just get some resources, build some structures... After a while you start using robots and remote control to do tasks without leaving your comfy armchair. Yet, naturally, the base is growing and it becomes impossible to manage the base all by yourself, a one puny human. If only you could just tell the robotic employees what they should be doing...

You can do that by using programming. In fact, by using programming you can get even better and more precise results since computers don't make mistakes like humans do (well, they do, but it's probably user/programmer/project manager's fault). They do exactly what they are said to do, without second thoughts. This makes them much more efficient, for example, try to calculate 56783.5678 * 1455.6 in your mind in a fraction of a second. Impossible, right? Not for a computer.

It doesn't end at mathematics. With proper algorithms computers can sort enormous chunks of data, find the shortest paths, build other robots, make us a coffee, basically they can do a lot of what we would want them to do. We "only" need to know a good algorithm and write it in a form understandable by computer. The algorithm creation is actually the hardest part, there are a lot of computer scientists trying to come up with the best solutions, or to prove that an efficient solution for particular problems doesn't even exist. We'll cover some of the popular algorithmic problems in later chapters.

However, you don't have to be a scientist to solve problems and create algorithms, this is what all programmers do every day. Problem solving is the essence of programming, this is where most of the fun lies. The goal is to see your program finally working, to understand  w h y  it's working, to make someone's (your) life easier. How to get alphabetically sorted list of all shop customers in a reasonable amount of time? How to get to New York from Warsaw in the shortest time possible? What is the most optimal way you can pack for your travel? How to shoot invading aliens while flying? These are only few examples of problems you can solve by programming!

\t;Programming Languages
So, how exactly can you talk with a computer? Obviously, you can't just say "build me a base" and expect the computer to understand you. Natural language is unnatural for machines. It's too sophisticated and ambiguous. Even humans can't understand each other from time to time! Try to explain to a machine that an idiom like "keep this under your hat" doesn't mean that the machine should literally put a thing under its gorgeous hat. You'll fail miserably. Machines need precise and determined sequence of instructions. How is the "keep" action defined? What is "this"? What does "under" mean? Where is "your hat"? Only after you precisely define all the words and grammar, a computer can understand a sentence using those definitions and try to execute it.

What is the language of electronic machines? Binary numbers! Zero when there is no current, one when there is. Simple concept, yet it still doesn't make the human-machine communication very easy. Back in the day, there was no place to type those long sequences of zeroes and ones. Programmers needed to plug in or out some cables, pull some levers, and that kind of stuff. If one made a mistake, the whole sequence had to be repeated again! In the picture below you can see the first world's computer, ENIAC.

\image eniac 20 20;

Don't worry, now it's much easier to program. After all, huge colorful displays and comfortable keyboards are common nowadays. Also, a lot of problems has already been solved, but some still have not known solution, and new problems constantly arise, often more complex than before.

Today, we use so called programming languages. They are formal, relatively simple languages, in some ways similar to the mathematical notation, although usually with far fewer odd symbols scaring outsiders. Programming languages are connecting the low-level computer language with the natural human language. When you write a program in a programming language, it is understandable by a human being (knowing the language) and at the same time it can be translated to a language understandable by a computer. The process of translating source code into machine code is called compilation, and is done by so called compilers.

\image compilation 20 20;

The language you'll be learning in this course is called CBOT. It was specifically created for programming robots in the game, yet it's based on widely used real-world programming languages, like C++ or Java. If you already know them, you'll beat this course in no time. If not, then it's even better, because that's why this programming course exists in the first place -- to teach you programming.

CBOT is a high-level language, which is the opposite of a low-level language. Low-level languages are close to machine, for example, they give you almost direct access to memory and processor instructions. Programs written in a low-level language are usually error-prone, less multiplatform and their source code is less readable. That's why most programmers use high-level languages which provide layers of abstraction, so for example, a programmer doesn't have to think about memory management and can focus more on the problem at hand.

\t;Glossary
Summing up, you should know the following terms after this lesson:

o Algorithm -- a precisely described sequence of actions to be performed in order to solve a specific problem.
o Program -- a form of an algorithm written for a computer.
o Programming language -- a notation for writing programs.
o Source code -- a program written in a programming language, which can be compiled, and then executed by a computer.
o Compiler -- a program that transforms source code to a low-level language or executable.
o Executable -- a program that can be executed by a computer, usually in a binary form; output of a compiler.
o Low-level language -- a programming language with direct access to machine components like memory, designed to be easily compiled rather than to be easy to read.
o High-level language -- a programming language usually hiding some machine related details from a programmer like memory management, designed to be easy to read by human rather than a computer.

Don't try to learn them by heart, those are not formal definitions. Just know how to explain them in your own words and understand them.

\b;Task
In this exercise you won't be doing anything related to programming yet. We just want you to get familiarized with the game basic controls. Click \l;here\u command; for more details.

Feel free to play around the map to see how the interface works. After you're done, move your \l;robot\u object\botgr; and \l;yourself\u object\human; to the \l;SpaceShip\u object\base; and take off.
